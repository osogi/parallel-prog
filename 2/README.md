# Task-2: Инструменты анализа кода

## Выбранный проект
https://github.com/halloweeks/networking/tree/main

Простенький TCP клиент/сервер написанный на C++. В основном будем изучать [сервер](./networking/server.cpp ), так как клиент довольно простой и в нём даже нет параллельных элементов.

### Пару слов о выборе проекта
Был выбран такой небольшой и простой проект, так как в более крупных проектах инструменты анализа выдавали слишком много логов, в которых было трудно разобраться, тем более без знания кодовой базы. 

## Результаты анализа
Ошибки и предупреждения, которые выдали инструменты, представлены в файлах [helgrind.out.txt](./helgrind.out.txt) и [sanitizer.out.txt ](./sanitizer.out.txt ). Оба инструмента "предположили", что глобальная переменная `connection` может быть подвержена гонке данных. Также helgrind несколько раз поругался на внутреннюю работу `printf`, вероятно вызвано тем что в *stdout* могут писать одновременно несколько потоков.

### Изучение результатов
Если изучить код и посмотреть, где изменяется переменная `connection`, можно найти два места: 
- в коде главного потока, обрабатывающего запросы на подключение новых клиентов, при успешном подключении  `connection` увеличивается:
	```c
		} else {
		printf("[INFO] NEW THREAD CREATED\n");
		connection++;
	}
	```

- в потоках, отвечающих за работу с клиентом (принятием и отсылки данных), при завершении работы `connection` уменьшается:
	```c
	    pthread_mutex_lock(&connection_mutex);
	    connection--;
	    pthread_mutex_unlock(&connection_mutex);
	   
	    printf("[INFO] THREAD TERMINATED\n");
	```

Интересно, что по отдельности эти части кода работают хорошо. Главный поток у нас может быть только один и не сможет поэтому дважды одновременно изменить переменную. А на потоках, которых может быть много, у нас на её изменение стоит мьютекс. 

Проблема появляется именно при их взаимодействии, так как в главном потоке у нас не стоит мьютекс на `connection`, то он может изменить её в тот момент когда это же делает поток клиента, который вроде как залочил мьютекс для этой переменной. Возможный фикс: добавить лок мьютекса и для главного потока.


### Гонка данных

Для того чтобы проверить возможно ли получить гонку данных, описанную выше, был написан небольшой [файл](./racer/racer_client.c ), который должен её породить. А так же к коду сервера был добавлен вывод числа соединений (`connection`), которые он поддерживает в данный момент. 

В результате удалось получить на сервере отрицательное число текущих подключений, следовательно, файл смог создать гонку данных, следовательно, её возможно получить.

```
<...>
------------------------
[INFO] CONNECTION CLOSED
[INFO] THREAD TERMINATED
[DEBUG] CONNECTION LIVE: -1
[INFO] CONNECTION CLOSED
[INFO] THREAD TERMINATED
[DEBUG] CONNECTION LIVE: -2
[TIME] PROCESS COMPLETE IN 0.00202 SEC
------------------------
[TIME] PROCESS COMPLETE IN 0.00493 SEC
------------------------
```

## Своя гонка данных

Сервер бы переписан под сервер любителей животных. В MVP этого продукта можно:
- вести свой профиль: указывать любишь ты кошек и собак
- смотреть чужие профили и оценивать их. Можно узнать
	- любит ли человек кошек и собак
	- и понравился ли этот профиль последнему посетившему

Код нового сервера можно найти в [папке](./my-networking), а в этом [коммите](https://github.com/osogi/parallel-prog/commit/3b44c94c5a282124740c268db3af430135079d3b) посмотреть внесённые изменения.

Основная интересность этой гонки данных в том, что если рассматривать переменные `love_dogs`, `love_cats` и `liked_by_last_visiter`, как независимые, то её не будет. Но все эти переменные хранятся в одном и том же байте, тем самым они влияют друг на друга (по крайней мере на моей машине с моим компилятором с указанными в makefile флагами), следовательно, на них всех должен быть общий мьютекс, а не отдельные как в представленной реализации. Либо стоит их разбить по отдельным байтам.

```c
struct profile_t {
    unsigned char love_dogs : 1, 
                  love_cats : 1, 
                  liked_by_last_visiter : 1;
};
```

### Результаты анализа
#### Санитайзер

Санитайзер не нашёл этот race condition, возможно дело в том что он рассматривает перечисленные выше переменные как независимые.

#### Helgrind

Helgrind обнаружил эту ошибку вот часть [лога](./my-helgrind.out.txt), где он сообщает о ней.

```
==396433== Possible data race during write of size 1 at 0x4DF60C0 by thread #2
==396433== Locks held: 1, at address 0x5253E88
==396433==    at 0x402163: user_t::set_love(int, int) (in /home/user1/github/university/parallel-prog/2/my-networking/server.elf)
==396433==    by 0x401A80: connection_handler(void*) (in /home/user1/github/university/parallel-prog/2/my-networking/server.elf)
==396433==    by 0x4842B1A: ??? (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_helgrind-amd64-linux.so)
==396433==    by 0x4BD2608: start_thread (pthread_create.c:477)
==396433==    by 0x4D0C352: clone (clone.S:95)
==396433== 
==396433== This conflicts with a previous write of size 1 by thread #3
==396433== Locks held: 1, at address 0x5253EC0
==396433==    at 0x402303: user_t::set_last_liked(int) (in /home/user1/github/university/parallel-prog/2/my-networking/server.elf)
==396433==    by 0x401BC2: connection_handler(void*) (in /home/user1/github/university/parallel-prog/2/my-networking/server.elf)
==396433==    by 0x4842B1A: ??? (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_helgrind-amd64-linux.so)
==396433==    by 0x4BD2608: start_thread (pthread_create.c:477)
==396433==    by 0x4D0C352: clone (clone.S:95)
```

Если убрать задания битового размера полей, тем самым сделать переменные независимыми, то как и ожидается helgrind не будет находить этот race condition (так как он невозможен). [Лог подтверждающий это](./my-helgrind.without-bits.out.txt) (он непустой, так как helgrind'у до сих пор не нравится printf и то что сервер пишет из разных потоков).